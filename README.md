## 튜토리얼 - 투두 리스트  
플럭스 아키텍처를 예제코드르 설명하기 위해 고전의 투두 MVC 어플리케이션을 만들어보자.
기동 가능한 전체 어플리케이션 코드는 리액트 깃 허브 저장소 내에 flux-todomvc 예제
디렉토리 내에 있지만 각각의 스텝을 개발하며 진행하자.  
  
시작하기 위해, 우리는 어떤 보일러플레이트와 모듈시스템과 기동하는 것이 필요하다. 
CommonJS 기반의 노드의 모듈 시스템은 아주 잘 들어맞으며 우리는 동작하는 리액트 보일러
플레이트를 빠르게 빌드 할 수 있다. 당신이 npm 이 설치 되었다는 가정하에 간단하게 
깃 허브에서 리액트 보일러 플레이트를 복제하고, 결과로서 나온 디렉토리를 터미널
(또는 당신이 선호하는 CLI 중 어떤것이라도) 상에서 네비게이트 해라. 그런 다음 브라우져
파이로 지속적으로 빌드 하기 위해 npm 스크립트 (npm install, then npm run build
, and lastly npm start)를 실행해라.  
  
The TodoMVC example has all this built into it as well, but if you're 
starting with react-boilerplate make sure you edit your package.json 
file to match the file structure and dependencies described in the
 TodoMVC example's package.json, or else your code won't match up with
  the explanations below.
  
## 소스코드 구조
index.html 파일이 결과로 bundle.js을 로드하는 entry point로 사용되지만, 대부분
의 우리의 코드는 js 디렉토리에 있다. Browserify로 그것을 해보자. 그리고 디렉토리
구조를 보기 위해 터미널에서 새로운 탭을 열어라. 그것은 아래와 같이 보일 것이다.

    myapp
      |
      + ...
      + js
        |
        + app.js
        + bundle.js // generated by Browserify whenever we make changes.
      + index.html
      + ...

다음은 js 디렉토리에 들어가보자. 그리고 어플리케이션의 기본 구조를 보자.
 
    myapp
      |
      + ...
      + js
        |
        + actions
        + components // all React components, both views and controller-views
        + constants
        + dispatcher
        + stores
        + app.js
        + bundle.js
      + index.html
      + ...
  
## Dispatcher 만들기  
지금 우리는 디스패쳐를 만들 준비가 되었다. 여기 디스패쳐 클래스의 소박한 예제가 있다.
자바스크립트 프라미스를 이용하여 작성하였으며, 제이크 아치발드의 ES6-Promises 모듈
로 polyfilled 되었다.
      
    var Promise = require('es6-promise').Promise;
    var assign = require('object-assign');
    
    var _callbacks = [];
    var _promises = [];
    
    var Dispatcher = function() {};
    Dispatcher.prototype = assign({}, Dispatcher.prototype, {
    
      /**
       * Register a Store's callback so that it may be invoked by an action.
       * @param {function} callback The callback to be registered.
       * @return {number} The index of the callback within the _callbacks array.
       */
      register: function(callback) {
        _callbacks.push(callback);
        return _callbacks.length - 1; // index
      },
    
      /**
       * dispatch
       * @param  {object} payload The data from the action.
       */
      dispatch: function(payload) {
        // First create array of promises for callbacks to reference.
        var resolves = [];
        var rejects = [];
        _promises = _callbacks.map(function(_, i) {
          return new Promise(function(resolve, reject) {
            resolves[i] = resolve;
            rejects[i] = reject;
          });
        });
        // Dispatch to callbacks and resolve/reject promises.
        _callbacks.forEach(function(callback, i) {
          // Callback can return an obj, to resolve, or a promise, to chain.
          // See waitFor() for why this might be useful.
          Promise.resolve(callback(payload)).then(function() {
            resolves[i](payload);
          }, function() {
            rejects[i](new Error('Dispatcher callback unsuccessful'));
          });
        });
        _promises = [];
      }
    });
    
    module.exports = Dispatcher;
  
공개 API의 기본적인 디스패쳐 구성은 두개의 메서드로 이루어져 있다. register()
와dispatch(). 우리는 각각의 저장소의 콜백을 저장소에 등록하기 위해 register()
 사용할 것이다. 우리는 콜백을 작동시키기 위한 우리의 actions에서 dispatch()를 
사용할 것이다.    
    
이제 우리는 우리의 앱에 더 특화된 디스패처를 생성하기 위한 모든 세팅을 했다.앱은
AppDispatcher를 호출할 것이다.
     
    var Dispatcher = require('./Dispatcher');
    var assign = require('object-assign');
    
    var AppDispatcher = assign({}, Dispatcher.prototype, {
    
      /**
       * A bridge function between the views and the dispatcher, marking the action
       * as a view action.  Another variant here could be handleServerAction.
       * @param  {object} action The data coming from the view.
       */
      handleViewAction: function(action) {
        this.dispatch({
          source: 'VIEW_ACTION',
          action: action
        });
      }
    
    });
    
    module.exports = AppDispatcher;
     
이제 우리는 우리의 필요에 더 특화된 디스패처를 구현했다. 우리는 액션 내의 뷰의 이벤트 
핸들러로 부터 헬프 펑션을 사용할 수 있다. 우리는 이후에 서버 업데이트를 위해 분해된
헬퍼를 제공하기 위해 확장할 수 있을 것이다. 하지만 그것은 지금은 필요한 것은 이것 뿐이다.

## 저장소 만들기     
우리는 스토어를 시작하기 위해 노드의 EventEmitter를 사용할 수 있다. 우리는
EventEmitter를 우리의 콘트롤러-뷰의 변경 이벤트를 방송하기 위해 필요하다. 그래서 
그것이 어떤게 보여지는가에 대해 살펴보자. 간결하게 하기 위해 어떠한 코드들은 생략이
 되었지만 전체 버전은 코드 예제에서 TodoStore.js을 보면 된다.
 
    var AppDispatcher = require('../dispatcher/AppDispatcher');
    var EventEmitter = require('events').EventEmitter;
    var TodoConstants = require('../constants/TodoConstants');
    var assign = require('object-assign');
    
    var CHANGE_EVENT = 'change';
    
    var _todos = {}; // collection of todo items
    
    /**
     * Create a TODO item.
     * @param {string} text The content of the TODO
     */
    function create(text) {
      // Using the current timestamp in place of a real id.
      var id = Date.now();
      _todos[id] = {
        id: id,
        complete: false,
        text: text
      };
    }
    
    /**
     * Delete a TODO item.
     * @param {string} id
     */
    function destroy(id) {
      delete _todos[id];
    }
    
    var TodoStore = assign({}, EventEmitter.prototype, {
    
      /**
       * Get the entire collection of TODOs.
       * @return {object}
       */
      getAll: function() {
        return _todos;
      },
    
      emitChange: function() {
        this.emit(CHANGE_EVENT);
      },
    
      /**
       * @param {function} callback
       */
      addChangeListener: function(callback) {
        this.on(CHANGE_EVENT, callback);
      },
    
      /**
       * @param {function} callback
       */
      removeChangeListener: function(callback) {
        this.removeListener(CHANGE_EVENT, callback);
      },
    
      dispatcherIndex: AppDispatcher.register(function(payload) {
        var action = payload.action;
        var text;
    
        switch(action.actionType) {
          case TodoConstants.TODO_CREATE:
            text = action.text.trim();
            if (text !== '') {
              create(text);
              TodoStore.emitChange();
            }
            break;
    
          case TodoConstants.TODO_DESTROY:
            destroy(action.id);
            TodoStore.emitChange();
            break;
    
          // add more cases for other actionTypes, like TODO_UPDATE, etc.
        }
    
        return true; // No errors. Needed by promise in Dispatcher.
      })
    
    });
    
    module.exports = TodoStore;

위에 코드에는 몇가지 중요한 것이 있다. 시작하기 위해, 우리는 _todos라 불리우는 개인
데이터 저장 구조를 관리하고 있다. 이 객체는 모든 개인적인 to-do 아이템을 포함하고 
있다. 